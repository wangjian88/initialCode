---
title: 高级程序设计--语法、关键字、变量类型、操作符、语句、函数
date: 2016-11-14 17:55:12
tags: [js,高级程序设计]
---

### 语法

1.区分大小写
要理解的第一个概念就是ECMAcript的一切（变量，函数名和操作符）都区分大小写。这就意味着，变量名test和Test分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字，但typeOf则完全可以是一个有效的函数名。

2.标识符

所谓标识符，就是指变量、函数、属性的名，或者函数的参数。标识符命名规则如下：
>* 第一个字符必须是一个字母、下划线(_)或一个美元符号($);
* 其他字符可以是字母、下划线、美元符号或数字。
 标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符(如 À 和 Æ),但我们不推荐这样做。 按照惯例,ECMAScript 标识符采用驼峰大小写格式,也就是第一个字母小写,剩下的每个单词的首字母大写,例如:irstSecond myCar  doSomethingImportant
* 不能把关键字、保留字、true、false 和 null 用作标识符。

3.注释
ECMAScript 使用 C 风格的注释,包括单行注释和块级注释。
>* 单行
```bash
//  alert(1)
/*	alert(1)
```
>* 多行
```bash
 <script type="text/javascript">
/**	alert(1)
 	alert(2)**/
	alert(3)
</script>
```

4.关键字和保留字
ECMA-262 描述了一组具有特定用途的关键字,这些关键字可用于表示控制语句的开始或结束,或 者用于执行特定操作等。按照规则,关键字也是语言保留的,不能用作标识符。以下就是 ECMAScript 的全部关键字(带*号上标的是第 5 版新增的关键字):
```bash
break case catch continue debugger* default delete do  instanceof else  new  finally  return for switch function     this if throwin try typeof var void while with
```

ECMA-262 还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定 的用途,但它们有可能在将来被用作关键字。以下是 ECMA-262 第 3 版定义的全部保留字:

page1|page2|page3|page4|page5|page6
:---:|:---:|:---:|:---:|:---:|:---:
abstract|boolean|byte|char|class|const
debugger|double|enum|export|extends|final
float|goto|import|int|interface|long
native|package|private|protected|public|implements
short|static|super|synchronized|throws|transient
volatile|

### 变量
ECMAScript的变量是松散类型的,所谓松散类型就是可以用来保存任何类型的数据。换句话说,每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用 var 操作符(注意 var 是一个关键字),后跟变量名(即一个标识符),有一点必须注意,即用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说,如果在函数中使用 var 定义一个变量,那么这个变量在函数退出后就会被销毁,例如:
```bash
function test(){
var message = "hi"; // 局部变量
}
test();
alert(message); // 错误!
```
这里,变量 message 是在函数中使用 var 定义的。当函数被调用时,就会创建该变量并为其赋值。而在此之后,这个变量又会立即被销毁,因此例子中的下一行代码就会导致错误。不过,可以像下面这样省略 var 操作符,从而创建一个全局变量:
```bash
function test(){					
	message = "hi"; // 全局变量
}					
test();
alert(message); // "hi"
```
这个例子省略了 var 操作符,因而 message 就成了全局变量。这样,只要调用过一次 test()函数,这个变量就有了定义,就可以在函数外部的任何地方被访问到。
>ps:虽然省略 var 操作符可以定义全局变量,但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护,而且如果有意地忽略了 var 操作符,也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。

>可以使用一条语句定义多个变量,只要像下面这样把每个变量(初始化或不初始化均可)用逗号分隔开即可:
```bash
 var  message = "hi",
      found = false,
      age = 29;
```
这个例子定义并初始化了 3 个变量。同样由于 ECMAScript 是松散类型的,因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的,但这样做可以提高可读性。

### 数据类型
ECMAScript 中有 5 种简单数类:Undefined、Null、Boolean、Number,String
和 String。还有 1 种复杂数据类型——Object,Object 本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制,而所有值最终都将是上述 6 种数据类型之一。乍一看,好像只有 6种数据类型不足以表示所有数据;但是,由于 ECMAScript 数据类型具有动态性,因此的确没有再定义其他数据类型的必要了。

1.Undefined 
Undefined类型只有一个值,即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时,这个变量的值就是 undefined,例如:
```bash
var message;
alert(message == undefined); //true
```
2.Null 类型是第二个只有一个值的数据类型,这个特殊的值是 null。从逻辑角度来看,null 值表示一个空对象指针,而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因,如下面的例子所示:
```bash
var car = null;
alert(typeof car);// "object"
```
如果定义的变量准备在将来用于保存对象,那么最好将该变量初始化为 null 而不是其他值。这样一来,只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用,如下面的例子所示:

```bash
if (car != null){
// 对 car 对象执行某些操作					
}
```

实际上,undefined 值是派生自 null 值的,因此 ECMA-262 规定对它们的相等性测试要返回 true:

```bash
alert(null == undefined);
```

如前所述,无论在什么情况下
都没有必要把一个变量的值显式地设置为 undefined,可是同样的规则对 null 却不适用。换句话说,只要意在保存对象的变量还没有真正保存对象,就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例,而且也有助于进一步区分 null 和 undefined。				

3.Boolean类型				
Boolean 类型是 ECMAScript 中使用得最多的一种类型,该类型只有两个字面值:true 和 false。这两个值与数字值不是一回事,因此 true 不一定等于 1,而 false 也不一定等于 0。
需要注意的是,Boolean 类型的字面值 true 和 false 是区分大小写的。也就是说,True 和 False(以及其他的混合大小写形式)都不是 Boolean 值,只是标识符。			可以对任何数据类型的值调用 Boolean()函数,而且总会返回一个 Boolean 值。至于返回的这个值是 true 还是 false,取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则。

数据类型|转化为true|转换为false
:---:|:---:|:---:
Boolean|true|false
string|任何非空字符串|“”空字符串
Number|任何非零数字值(包括无穷大)|0和NaN(参见本章后面有关NaN的内容) 
Object|任何对象|null
Undefined|n/a1?|undifind 

4.Number类型
Number 类型应该是 ECMAScript 中最令人关注的数据类型了,这种类型使IEEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。为支持各种数值类型,ECMA-262 定义了不同的数值字面量格式。				
对于那些极大或极小的数值,可以用 e 表示法(即科学计数法)表示的浮点数值表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂。ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值(例如,0.0000003 会被转换成 3e*-7)。
var floatNum = 3.125e7; // 等于31250000				
浮点数值的最高精度是 17 位小数,但在进行算术计算时其精确度远远不如整数。例如,0.1 加 0.2的结果不是 0.3,而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。
例如:

```bash
if (a + b == 0.3){ // 不要做这样的测试!
	alert("You got 0.3.");					
}
```

在这个例子中,我们测试的是两个数的和是不是等于 0.3。如果这两个数是 0.05 和 0.25,或者是 0.15和 0.15 都不会有问题。而如前所述,如果这两个数是 0.1 和 0.2,那么测试将无法通过。因此,永远不要测试某个特定的浮点数值。
> ps:关于浮点数值计算会产生舍入误差的问题,有一点需要明确:这是使用基于IEEE754 数值的浮点计算的通病,ECMAScript并非独此一家;其他使用相同数值格式的语言也存在这个问题。

> NaN
NaN,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。例如,在其他编程语言中,任何数值除以 0 都会导致错误,从而停止代码执行。但在 ECMAScript 中,任何数值除以 0 会返回 NaN1,因此不会影响其他代码的执行。@原书如此,但实际上只有 0 除以 0 才会返回 NaN,正数除以 0 返回 Infinity,负数除以 0 返回-Infinity。	
NaN 本身有两个非同寻常的特点。首先,任何涉及 NaN 的操作(例如 NaN/10)都会返回 NaN,这
个特点在多步计算中有可能导致问题。其次,NaN 与任何值都不相等,包括 NaN 本身。例如,下面的代码会返回 false:	
```bash			
alert(NaN == NaN); //false
```
针对 NaN 的这两个特点,ECMAScript 定义了 isNaN()函数。这个函数接受一个参数,该参数可以
是任何类型,而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后,会尝试
将这个值转换为数值。某些不是数值的值会直接转换为数值,例如字符串"10"或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。请看下面的例子:

```bash
    alert(isNaN(NaN));//true
    alert(isNaN(10));//false(10 是一个数值)
    alert(isNaN("10"));//false(可以被转换成数值 10)
    alert(isNaN("blue"));//true(不能转换成数值)
    alert(isNaN(true));/false(可以被转换成数值 1)
```
> 数值转换
有 3 个函数可以把非数值转换为数值:Number()、parseInt()和 parseFloat()。第一个函数,
即转型函数 Number()可以用于任何数据类型,而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。					
Number()函数的转换规则如下。
 如果是 Boolean 值,true 和 false 将分别被转换为 1 和 0。
 如果是数字值,只是简单的传入和返回。
 如果是 null 值,返回 0。
 如果是 undefined,返回 NaN。
 如果是字符串,遵循下列规则:							
  如果字符串中只包含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,即"1“会变成 1,"123"会变成 123,而"011"会变成 11(注意:前导的零被忽略了);		
  如果字符串中包含有效的浮点格式,如"1.1",则将其转换为对应的浮点数值(同样,也会忽略前导零);					
  如果字符串中包含有效的十六进制格式,例如"0xf",则将其转换为相同大小的十进制整数值;						
  如果字符串是空的(不包含任何字符),则将其转换为 0;				
  如果字符串中包含除上述格式之外的字符,则将其转换为 NaN。
 如果是对象,则调用对象的 valueOf()方法,然后依照前面的规则转换返回的值。如果转换的结果是 NaN,则调用对象的 toString()方法,然后再次依照前面的规则转换返回的字符串值。
					
由于 Number()函数在转换字符串时比较复杂而且不够合理,因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时,更多的是看其是否符合数值模式。它会忽略字符串前面的空格,直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号,parseInt()就会返回 NaN;也就是说,用 parseInt()转换空字符串会返回 NaN(Number()对空字符返回 0)。如果第一个字符是数字字符,parseInt()会继续解析第二个字符,直到解析完所有后续字符或者遇到了一个非数字字符。例如,"1234blue"会被转换为 1234,因为"blue"会被完全忽略。类似地,"22.5" 4会被转换为 22,因为小数点并不是有效的数字字符。
与 parseInt()函数类似,parseFloat()也是从第一个字符(位置 0)开始解析每个字符。而且也是一直解析到字符串末尾,或者解析到遇见一个无效的浮点数字字符为止。也就是说,字符串中的第一个小数点是有效的,而第二个小数点就是无效的了,因此它后面的字符串将被忽略。举例来说,"22.34.5"将会被转换为 22.34。除了第一个小数点有效之外,parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式,也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值,因此它没有用第二个参数指定基数的用法。最后还要注意一点:如果字符串包含的是一个可解析为整数的数(没有小数点,或者小数点后都是零),parseFloat()会返回整数。以下是使用 parseFloat()转换数值的几个典型示例。

```bash
var num1 = parseFloat("1234blue");//1234 (整数)
var num2 = parseFloat("0xA");//0
var num3 = parseFloat("22.5");//22.5
var num4 = parseFloat("22.34.5");//22.34
var num5 = parseFloat("0908.5");//908.5
var num6 = parseFloat("3.125e7");//31250000					
```

#### 5.String 					
String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列,即字符串。				
String 数据类型包含一些特殊的字符字面量,也叫转义序列,用于表示非打印字符,或者具其他用途的字符。这些字符字面量如下表所示:

```bash
\n     换行

\t     制表

\b     空格

\r     回车

\f     进纸

\\     斜杠

\'     单引号('),在用单引号表示的字符串中使用。例如:'He said, \'hey.\''

\"     双引号("),在用双引号表示的字符串中使用。例如:"He said, \"hey.\""

\xnn     以十六进制代码nn表示的一个字符(其中n为0~F)。例如,\x41表示"A"

\unnnn   以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F)。例如,\u03a3表示希腊字符Σ	
```

字符串的特点
ECMAScript中的字符串是不可变的,也就是说,字符串一旦创建,它们的值就不能改变。要改变某个变量保存的字符串,首先要销毁原来的字符串,然后再用另一个包含新值的字符串填充该量,例如:

```bash
    var lang = "Java";
    lang = lang + "Script";
```

以上示例中的变量 lang 开始时包含字符串"Java"。而第二行代码把 lang 的值重新定义为"Java"与"Script"的组合,即"JavaScript"。实现这个操作的过程如下:首先创建一个能容纳 10 个字符的新字符串,然后在这个字符串中填充"Java"和"Script",最后一步是销毁原来的字符串"Java"和字符串"Script",因为这两个字符串已经没用了。

<div>
	![](https://wangjian88.github.io/img/str.gif)
</div>

6 Object类型				
ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建
的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和(或)方法,就可以创建定义对象,如下所示:			
var o = new Object();				
这个语法与 Java 中创建对象的语法相似;但在 ECMAScript 中,如果不给构造函数传递参数,则可以省略后面的那一对圆括号。也就是说,在像前面这个示例一样不传递参数的情况下,完全可以省略那对圆括号(但这不是推荐的做法):			
var o = new Object; // 有效,但不推荐省略圆括号		
仅仅创建 Object 的实例并没有什么用处,但关键是要理解一个重要的思想:即在 ECMAScript 中,
(就像 Java 中的 java.lang.Object 对象一样)Object 类型是所有它的实例的基础。换句话说, 		
Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。Object 的每个实例都具有下列属性和方法。					
  constructor:保存着用于创建当前对象的函数。对于前面的例子而言,构造函数(constructor) 8就是 Object()。
  hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例
的原型中)是否存在。其中,作为参数的属性名(propertyName)必须以字符串形式指定(例如:o.hasOwnProperty("name"))。
isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型(第 5 章将讨论原型)。
 propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句(本章后面将会讨论)来枚举。与 hasOwnProperty()方法一样,作为参数的属性名必须以字符串形式指定。					
  toLocaleString():返回对象的字符串表示,该字符串与执行环境的地区对应。							
  toString():返回对象的字符串表示。
valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。由于在 ECMAScript 中 Object 是所有对象的基础,因此所有对象都具有这些基本的属性和方法。第 5 章和第 6 章将详细介绍 Object 与其他对象的关系。
ps:从技术角度讲,ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象,比如 BOM 和 DOM 中的对象,都属于宿主对象,因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象,因此宿主对象可能会也可能不会继承 Object。















### 操作符
### 语句
### 函数
### 小结