---
title: 高级程序设计--语法、变量类型、操作符、语句、函数(上)
date: 2016-11-14 17:55:12
tags: [js,高级程序设计]
---

### 语法

1.区分大小写
要理解的第一个概念就是ECMAcript的一切（变量，函数名和操作符）都区分大小写。这就意味着，变量名test和Test分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字，但typeOf则完全可以是一个有效的函数名。

<!--more-->

2.标识符

所谓标识符，就是指变量、函数、属性的名，或者函数的参数。标识符命名规则如下：
>* 第一个字符必须是一个字母、下划线(_)或一个美元符号($);
* 其他字符可以是字母、下划线、美元符号或数字。
 标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符(如 À 和 Æ),但我们不推荐这样做。 按照惯例,ECMAScript 标识符采用驼峰大小写格式,也就是第一个字母小写,剩下的每个单词的首字母大写,例如:irstSecond myCar  doSomethingImportant
* 不能把关键字、保留字、true、false 和 null 用作标识符。

3.注释
ECMAScript 使用 C 风格的注释,包括单行注释和块级注释。
>* 单行
```bash
//  alert(1)
/*	alert(1)
```
>* 多行
```bash
 <script type="text/javascript">
/**	alert(1)
 	alert(2)**/
	alert(3)
</script>
```

4.关键字和保留字
ECMA-262 描述了一组具有特定用途的关键字,这些关键字可用于表示控制语句的开始或结束,或 者用于执行特定操作等。按照规则,关键字也是语言保留的,不能用作标识符。以下就是 ECMAScript 的全部关键字(带*号上标的是第 5 版新增的关键字):
```bash
break case catch continue debugger* default delete do  instanceof else  new  finally  return for switch function     this if throwin try typeof var void while with
```

ECMA-262 还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定 的用途,但它们有可能在将来被用作关键字。以下是 ECMA-262 第 3 版定义的全部保留字:

page1|page2|page3|page4|page5|page6
:---:|:---:|:---:|:---:|:---:|:---:
abstract|boolean|byte|char|class|const
debugger|double|enum|export|extends|final
float|goto|import|int|interface|long
native|package|private|protected|public|implements
short|static|super|synchronized|throws|transient
volatile|

### 变量
ECMAScript的变量是松散类型的,所谓松散类型就是可以用来保存任何类型的数据。换句话说,每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用 var 操作符(注意 var 是一个关键字),后跟变量名(即一个标识符),有一点必须注意,即用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说,如果在函数中使用 var 定义一个变量,那么这个变量在函数退出后就会被销毁,例如:
```bash
function test(){
var message = "hi"; // 局部变量
}
test();
alert(message); // 错误!
```
这里,变量 message 是在函数中使用 var 定义的。当函数被调用时,就会创建该变量并为其赋值。而在此之后,这个变量又会立即被销毁,因此例子中的下一行代码就会导致错误。不过,可以像下面这样省略 var 操作符,从而创建一个全局变量:
```bash
function test(){					
	message = "hi"; // 全局变量
}					
test();
alert(message); // "hi"
```
这个例子省略了 var 操作符,因而 message 就成了全局变量。这样,只要调用过一次 test()函数,这个变量就有了定义,就可以在函数外部的任何地方被访问到。
>ps:虽然省略 var 操作符可以定义全局变量,但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护,而且如果有意地忽略了 var 操作符,也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。

>可以使用一条语句定义多个变量,只要像下面这样把每个变量(初始化或不初始化均可)用逗号分隔开即可:
```bash
 var  message = "hi",
      found = false,
      age = 29;
```
这个例子定义并初始化了 3 个变量。同样由于 ECMAScript 是松散类型的,因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的,但这样做可以提高可读性。

### 数据类型
ECMAScript 中有 5 种简单数类:Undefined、Null、Boolean、Number,String
和 String。还有 1 种复杂数据类型——Object,Object 本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制,而所有值最终都将是上述 6 种数据类型之一。乍一看,好像只有 6种数据类型不足以表示所有数据;但是,由于 ECMAScript 数据类型具有动态性,因此的确没有再定义其他数据类型的必要了。

1.Undefined 
Undefined类型只有一个值,即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时,这个变量的值就是 undefined,例如:
```bash
var message;
alert(message == undefined); //true
```
2.Null 类型是第二个只有一个值的数据类型,这个特殊的值是 null。从逻辑角度来看,null 值表示一个空对象指针,而这也正是使用 typeof 操作符检测 null 值时会返回"object"的原因,如下面的例子所示:
```bash
var car = null;
alert(typeof car);// "object"
```
如果定义的变量准备在将来用于保存对象,那么最好将该变量初始化为 null 而不是其他值。这样一来,只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用,如下面的例子所示:

```bash
if (car != null){
// 对 car 对象执行某些操作					
}
```

实际上,undefined 值是派生自 null 值的,因此 ECMA-262 规定对它们的相等性测试要返回 true:

```bash
alert(null == undefined);
```

如前所述,无论在什么情况下
都没有必要把一个变量的值显式地设置为 undefined,可是同样的规则对 null 却不适用。换句话说,只要意在保存对象的变量还没有真正保存对象,就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例,而且也有助于进一步区分 null 和 undefined。				

3.Boolean类型				
Boolean 类型是 ECMAScript 中使用得最多的一种类型,该类型只有两个字面值:true 和 false。这两个值与数字值不是一回事,因此 true 不一定等于 1,而 false 也不一定等于 0。
需要注意的是,Boolean 类型的字面值 true 和 false 是区分大小写的。也就是说,True 和 False(以及其他的混合大小写形式)都不是 Boolean 值,只是标识符。			可以对任何数据类型的值调用 Boolean()函数,而且总会返回一个 Boolean 值。至于返回的这个值是 true 还是 false,取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则。

数据类型|转化为true|转换为false
:---:|:---:|:---:
Boolean|true|false
string|任何非空字符串|“”空字符串
Number|任何非零数字值(包括无穷大)|0和NaN(参见本章后面有关NaN的内容) 
Object|任何对象|null
Undefined|n/a1?|undifind 

4.Number类型
Number 类型应该是 ECMAScript 中最令人关注的数据类型了,这种类型使IEEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。为支持各种数值类型,ECMA-262 定义了不同的数值字面量格式。				
对于那些极大或极小的数值,可以用 e 表示法(即科学计数法)表示的浮点数值表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂。ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值(例如,0.0000003 会被转换成 3e*-7)。
var floatNum = 3.125e7; // 等于31250000				
浮点数值的最高精度是 17 位小数,但在进行算术计算时其精确度远远不如整数。例如,0.1 加 0.2的结果不是 0.3,而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。
例如:

```bash
if (a + b == 0.3){ // 不要做这样的测试!
	alert("You got 0.3.");					
}
```

在这个例子中,我们测试的是两个数的和是不是等于 0.3。如果这两个数是 0.05 和 0.25,或者是 0.15和 0.15 都不会有问题。而如前所述,如果这两个数是 0.1 和 0.2,那么测试将无法通过。因此,永远不要测试某个特定的浮点数值。
> ps:关于浮点数值计算会产生舍入误差的问题,有一点需要明确:这是使用基于IEEE754 数值的浮点计算的通病,ECMAScript并非独此一家;其他使用相同数值格式的语言也存在这个问题。

> NaN
NaN,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。例如,在其他编程语言中,任何数值除以 0 都会导致错误,从而停止代码执行。但在 ECMAScript 中,任何数值除以 0 会返回 NaN1,因此不会影响其他代码的执行。@原书如此,但实际上只有 0 除以 0 才会返回 NaN,正数除以 0 返回 Infinity,负数除以 0 返回-Infinity。	
NaN 本身有两个非同寻常的特点。首先,任何涉及 NaN 的操作(例如 NaN/10)都会返回 NaN,这
个特点在多步计算中有可能导致问题。其次,NaN 与任何值都不相等,包括 NaN 本身。例如,下面的代码会返回 false:	
```bash			
alert(NaN == NaN); //false
```
针对 NaN 的这两个特点,ECMAScript 定义了 isNaN()函数。这个函数接受一个参数,该参数可以
是任何类型,而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后,会尝试
将这个值转换为数值。某些不是数值的值会直接转换为数值,例如字符串"10"或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。请看下面的例子:

```bash
    alert(isNaN(NaN));//true
    alert(isNaN(10));//false(10 是一个数值)
    alert(isNaN("10"));//false(可以被转换成数值 10)
    alert(isNaN("blue"));//true(不能转换成数值)
    alert(isNaN(true));/false(可以被转换成数值 1)
```
> 数值转换
有 3 个函数可以把非数值转换为数值:Number()、parseInt()和 parseFloat()。第一个函数,
即转型函数 Number()可以用于任何数据类型,而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。					
Number()函数的转换规则如下。
 如果是 Boolean 值,true 和 false 将分别被转换为 1 和 0。
 如果是数字值,只是简单的传入和返回。
 如果是 null 值,返回 0。
 如果是 undefined,返回 NaN。
 如果是字符串,遵循下列规则:							
  如果字符串中只包含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,即"1“会变成 1,"123"会变成 123,而"011"会变成 11(注意:前导的零被忽略了);		
  如果字符串中包含有效的浮点格式,如"1.1",则将其转换为对应的浮点数值(同样,也会忽略前导零);					
  如果字符串中包含有效的十六进制格式,例如"0xf",则将其转换为相同大小的十进制整数值;						
  如果字符串是空的(不包含任何字符),则将其转换为 0;				
  如果字符串中包含除上述格式之外的字符,则将其转换为 NaN。
 如果是对象,则调用对象的 valueOf()方法,然后依照前面的规则转换返回的值。如果转换的结果是 NaN,则调用对象的 toString()方法,然后再次依照前面的规则转换返回的字符串值。
					
由于 Number()函数在转换字符串时比较复杂而且不够合理,因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时,更多的是看其是否符合数值模式。它会忽略字符串前面的空格,直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号,parseInt()就会返回 NaN;也就是说,用 parseInt()转换空字符串会返回 NaN(Number()对空字符返回 0)。如果第一个字符是数字字符,parseInt()会继续解析第二个字符,直到解析完所有后续字符或者遇到了一个非数字字符。例如,"1234blue"会被转换为 1234,因为"blue"会被完全忽略。类似地,"22.5" 4会被转换为 22,因为小数点并不是有效的数字字符。
与 parseInt()函数类似,parseFloat()也是从第一个字符(位置 0)开始解析每个字符。而且也是一直解析到字符串末尾,或者解析到遇见一个无效的浮点数字字符为止。也就是说,字符串中的第一个小数点是有效的,而第二个小数点就是无效的了,因此它后面的字符串将被忽略。举例来说,"22.34.5"将会被转换为 22.34。除了第一个小数点有效之外,parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式,也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值,因此它没有用第二个参数指定基数的用法。最后还要注意一点:如果字符串包含的是一个可解析为整数的数(没有小数点,或者小数点后都是零),parseFloat()会返回整数。以下是使用 parseFloat()转换数值的几个典型示例。

```bash
var num1 = parseFloat("1234blue");//1234 (整数)
var num2 = parseFloat("0xA");//0
var num3 = parseFloat("22.5");//22.5
var num4 = parseFloat("22.34.5");//22.34
var num5 = parseFloat("0908.5");//908.5
var num6 = parseFloat("3.125e7");//31250000					
```

#### 5.String 					
String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列,即字符串。				
String 数据类型包含一些特殊的字符字面量,也叫转义序列,用于表示非打印字符,或者具其他用途的字符。这些字符字面量如下表所示:

```bash
\n     换行

\t     制表

\b     空格

\r     回车

\f     进纸

\\     斜杠

\'     单引号('),在用单引号表示的字符串中使用。例如:'He said, \'hey.\''

\"     双引号("),在用双引号表示的字符串中使用。例如:"He said, \"hey.\""

\xnn     以十六进制代码nn表示的一个字符(其中n为0~F)。例如,\x41表示"A"

\unnnn   以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F)。例如,\u03a3表示希腊字符Σ	
```

字符串的特点
ECMAScript中的字符串是不可变的,也就是说,字符串一旦创建,它们的值就不能改变。要改变某个变量保存的字符串,首先要销毁原来的字符串,然后再用另一个包含新值的字符串填充该量,例如:

```bash
    var lang = "Java";
    lang = lang + "Script";
```

以上示例中的变量 lang 开始时包含字符串"Java"。而第二行代码把 lang 的值重新定义为"Java"与"Script"的组合,即"JavaScript"。实现这个操作的过程如下:首先创建一个能容纳 10 个字符的新字符串,然后在这个字符串中填充"Java"和"Script",最后一步是销毁原来的字符串"Java"和字符串"Script",因为这两个字符串已经没用了。

<div style="text-align:center">
	![](https://wangjian88.github.io/img/str.gif)
</div>

#### 6.Object类型				
ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建
的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和(或)方法,就可以创建定义对象,如下所示:

```bash			
var o = new Object();
```

这个语法与 Java中创建对象的语法相似;但在ECMAScript中,如果不给构造函数传递参数,则可以省略后面的那一对圆括号。也就是说,在像前面这个示例一样不传递参数的情况下,完全可以省略那对圆括号(但这不是推荐的做法):

```bash			
var o = new Object; // 有效,但不推荐省略圆括号		
```

仅仅创建 Object 的实例并没有什么用处,但关键是要理解一个重要的思想:即在 ECMAScript 中,(就像 Java 中的 java.lang.Object 对象一样)Object类型是所有它的实例的基础。换句话说, Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。Object 的每个实例都具有下列属性和方法。					
>1.constructor:保存着用于创建当前对象的函数。对于前面的例子而言,构造函数(constructor) 8就是 Object()。
2.hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例
的原型中)是否存在。其中,作为参数的属性名(propertyName)必须以字符串形式指定(例如:o.hasOwnProperty("name"))。
3.isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型(第 5 章将讨论原型)。
4.propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句(本章后面将会讨论)来枚举。与 hasOwnProperty()方法一样,作为参数的属性名必须以字符串形式指定。					
5.toLocaleString():返回对象的字符串表示,该字符串与执行环境的地区对应。							
6.toString():返回对象的字符串表示。
7.valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。由于在 ECMAScript 中 Object 
是所有对象的基础,因此所有对象都具有这些基本的属性和方法。第 5 章和第 6 章将详细介绍 Object 与其他对象的关系。
#### ps:从技术角度讲,ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象,比如 BOM 和 DOM 中的对象,都属于宿主对象,因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象,因此宿主对象可能会也可能不会继承 Object。

### 操作符

ECMA-262 描述了一组用于操作数据值的操作符,包括算术操作符(如加号和减号)、位操作符、 关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于,它们能够适用于很多值,例如字 符串、数字值、布尔值,甚至对象。不过,在应用于对象时,相应的操作符通常都会调用对象的 valueOf() 和(或)toString()方法,以便取得可以操作的值。 
1 一元操作符
只能操作一个值的操作符叫做一元操作符。一元操作是ECMAScript中最简单的操作符。
> 递增和递减操作符
递增和递减操作符直接借鉴自 C,而且各有两个版本:前置型和后置型。顾名思义,前置型应该位于要操作的变量之前,而后置型则应该位于要操作的变量之后。因此,在使用前置递增操作符给一个数 值加 1 时,要把两个加号(++)放在这个数值变量前面,如下所示:
```bash
    var age = 29;
    ++age;
```
> 在这个例子中,前置递增操作符把 age 的值变成了 30(为 29 加上了 1)。实际上,执行这个前置递 增操作与执行以下操作的效果相同:
```bash
var age = 29;
age = age + 1;```
> 执行前置递减操作的方法也类似,结果会从一个数值中减去 1。使用前置递减操作符时,要把两个 减号(--)放在相应变量的前面,如下所示:
```bash var age = 29;
--age;```
>这样,age 变量的值就减少为 28(从 29 中减去了 1)。
执行前置递增和递减操作时,变量的值都是在语句被求值以前改变的。(在计算机科学领域,这种 情况通常被称作副效应。)请看下面这个例子。 
```bash var age = 29;
var anotherAge = --age + 2;
alert(age); // 输出28 
alert(anotherAge); // 输出30 ```
> 由于前置递增和递减操作与执行语句的优先级相等,因此整个语句会从左至右被求值。再看一个例子:
```bash var num1 = 2;
var num2 = 20;
var num3 = --num1 + num2;// 等于 21
var num4 = num1 + num2; // 等于 21 ```
> 把递增操作符放在变量后面并不会改变语句的结果,因为递增是这条语句的唯一操作。但是,当语 句中还包含其他操作时,上述区别就会非常明显了。请看下面的例子:
```bash var num1 = 2;
var num2 = 20; 
var num3 = num1-- + num2; // 等于 22 
var num4 = num1 + num2;// 21 ```
> 这里仅仅将前置递减改成了后置递减,就立即可以看到差别。在前面使用前置递减的例子中,num3 和 num4 最后都等于 21。而在这个例子中,num3 等于 22,num4 等于 21。差别的根源在于,这里在计 算 num3 时使用了 num1 的原始值(2)完成了加法计算,而 num4 则使用了递减后的值(1)。

#### 一元加和减操作符
> 绝大多数开发人员对一元加和减操作符都不会陌生,而且这两个 ECMAScript 操作符的作用与数学 书上讲的完全一样。一元加操作符以一个加号(+)表示,放在数值前面,对数值不会产生任何影响, 如下面的例子所示:
var num = 25;
num = +num; // 仍然是25
不过,在对非数值应用一元加操作符时,该操作符会像 Number()转型函数一样对这个值执行转换。 换句话说,布尔值 false 和 true 将被转换为 0 和 1,字符串值会被按照一组特殊的规则进行解析,而 对象是先调用它们的 valueOf()和(或)toString()方法,再转换得到的值。

#### 布尔操作符
> 在一门编程语言中,布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力,那么 诸如 if...else 和循环之类的语句就不会有用武之地了。布尔操作符一共有 3 个:非(NOT)、与(AND) 和或(OR)。
1. 逻辑非
逻辑非操作符由一个叹号(!)表示,可以应用于 ECMAScript 中的任何值。无论这个值是什么数据 类型,这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值,然后再 对其求反。也就是说,逻辑非操作符遵循下列规则:
 如果操作数是一个对象,返回 false;
 如果操作数是一个空字符串,返回 true;
 如果操作数是一个非空字符串,返回 false;
 如果操作数是数值 0,返回 true;
 如果操作数是任意非 0 数值(包括 Infinity),返回 false; 
 如果操作数是 null,返回 true;
 如果操作数是 NaN,返回 true;
 如果操作数是 undefined,返回 true。
下面几个例子展示了应用上述规则的结果:
alert(!false);// true
alert(!"blue");// false
alert(!0);// true
alert(!NaN);// true
alert(!"");// true
alert(!12345);// false
逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符,实际 上就会模拟 Boolean()转型函数的行为。其中,第一个逻辑非操作会基于无论什么操作数返回一个布 尔值,而第二个逻辑非操作则对该布尔值求反,于是就得到了这个值真正对应的布尔值。当然,最终结 果与对这个值使用 Boolean()函数相同。
2. 逻辑与 逻辑与操作符由两个和号(&&)表示,有两个操作数。 逻辑与操作可以应用于任何类型的操作数,而不仅仅是布尔值。在有一个操作数不是布尔值的情况 下,逻辑与操作就不一定返回布尔值;此时,它遵循下列规则:
  如果第一个操作数是对象,则返回第二个操作数;
  如果第二个操作数是对象,则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;
  如果两个操作数都是对象,则返回第二个操作数;
  如果有一个操作数是 null,则返回 null;
  如果有一个操作数是 NaN,则返回 NaN;
  如果有一个操作数是 undefined,则返回 undefined。
逻辑与操作属于短路操作,即如果第一个操作数能够决定结果,那么就不会再对第二个操作数求值。 对于逻辑与操作而言,如果第一个操作数是 false,则无论第二个操作数是什么值,结果都不再可能是 true 了。来看下面的例子:
var found = true;
var result = (found && someUndefinedVariable);/ 这一行不会执行
alert(result); // 这里会发生错误 
在上面的代码中,当执行逻辑与操作时会发生错误,因为变量 someUndefinedVariable 没有声 明。由于变量 found 的值是 true,所以逻辑与操作符会继续对变量 someUndefinedVariable 求值。但 someUndefinedVariable 尚未定义,因此就会导致错误。这说明不能在逻辑与操作中使用未定义 的值。如果像下面这个例中一样,将 found 的值设置为 false,就不会发生错误了:
var found = false;
var result = (found && someUndefinedVariable); alert(result); // 会执行("false") 
在这个例子中,警告框会显示出来。无论变量 someUndefinedVariable 有没有定义,也永远不 会对它求值,因为第一个操作数的值是 false。而这也就意味着逻辑与操作的结果必定是 false,根本 用不着再对&&右侧的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。
3. 逻辑或 逻辑或操作符由两个竖线符号(||)表示,有两个操作数 
与逻辑与操作相似,如果有一个操作数不是布尔值,逻辑或也不一定返回布尔值;此时,它遵循下 列规则:
>  如果第一个操作数是对象,则返回第一个操作数;
 如果第一个操作数的求值结果为 false,则返回第二个操作数; 
 如果两个操作数都是对象,则返回第一个操作数;
 如果两个操作数都是 null,则返回 null;
 如果两个操作数都是 NaN,则返回 NaN;
 如果两个操作数都是 undefined,则返回 undefined。
与逻辑与操作符相似,逻辑或操作符也是短路操作符。也就是说,如果第一个操作数的求值结果为 true,就不会对第二个操作数求值了。下面看一个例子: 
var found = true;
var result = (found || someUndefinedVariable); // 不会发生错误 alert(result); // 会执行("true") 
我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。例如:
  var myObject = preferredObject || backupObject;
在这个例子中,变量 myObject 将被赋予等号后面两个值中的一个。变量 preferredObject 中包 含优先赋给变量 myObject 的值,变量 backupObject 负责在 preferredObject 中不包含有效值的情况下提供后备值。如果preferredObject 的值不是 null,那么它的值将被赋给 myObject;如果 1 是 null,则将 backupObject 的值赋给 myObject。ECMAScript 程序的赋值语句经常会使用这种模式, 本书也将采用这种模式。
 3 关系操作符 
小于(<)、大于(>)、小于等于(<=)和大于等于(>=)这几个关系操作符用于对两个值进行比较,比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值,如下面的例子所示: 
var result1 = 5 > 3; //true 
var result2 = 5 < 3; //false 
与 ECMAScript 中的其他操作符一样,当关系操作符的操作数使用了非数值时,也要进行数据转换 或完成某些奇怪的操作。以下就是相应的规则。
  如果两个操作数都是数值,则执行数值比较。
  如果两个操作数都是字符串,则比较两个字符串对应的字符编码值。
  如果一个操作数是数值,则将另一个操作数转换为一个数值,然后执行数值比较。
  如果一个操作数是对象,则调用这个对象的 valueOf()方法,用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法,则调用 toString()方法,并用得到的结果根据前面的规则执行比较。
    如果一个操作数是布尔值,则先将其转换为数值,然后再执行比较
在使用关系操作符比较两个字符串时,会执行一种奇怪的操作。很多人都会认为,在比较字符串值 时,小于的意思是“在字母表中的位置靠前”,而大于则意味着“在字母表中的位置靠后”,但实际上完 全不是那么回事。在比较字符串时,实际比较的是两个字符串中对应位置的每个字符的字符编码值。经 过这么一番比较之后,再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码,因 此我们就会看到如下所示的奇怪现象: 
var result = "Brick" < "alphabet";    //true
在这个例子中,字符串"Brick"被认为小于字符串"alphabet"。原因是字母 B 的字符编码为 66, 而字母 a 的字符编码是 97。如果要真正按字母表顺序比较字符串,就必须把两个操作数转换为相同的大 小写形式(全部大写或全部小写),然后再执行比较,如下所示:
var result = "Brick".toLowerCase() < "alphabet".toLowerCase();
//false
通过将两个操作数都转换为小写形式,就可以得出"alphabet"按字母表顺序排在"Brick"之前的 正确判断了。另一种奇怪的现象发生在比较两个数字字符串的情况下,比如下面这个例子:
var result = "23" < "3";    //true
确实,当比较字符串"23"是否小于"3"时,结果居然是 true。这是因为两个操作数都是字符串, 而字符串比较的是字符编码("2"的字符编码是 50,而"3"的字符编码是 51)。不过,如果像下面例子 中一样,将一个操作数改为数值,比较的结果就正常了:
var result = "23" < 3;    //false
此时,字符串"23"会被转换成数值 23,然后再与 3 进行比较,因此就会得到合理的结果。在比较 数值和字符串时,字符串都会被转换成数值,然后再以数值方式与另一个数值比较。当然,这个规则对 前面的例子是适用的。可是,如果那个字符串不能被转换成一个合理的数值呢?比如:
var result = "a" < 3; // false,因为"a"被转换成了 NaN 
由于字母"a"不能转换成合理的数值,因此就被转换成了 NaN。根据规则,任何操作数与 NaN 进行关系比较，结果都是false。于是，就有了下面有趣的现象 
var result1 = NaN < 3; //false
var result2 = NaN >= 3; //false 
按照常理,如果一个值不小于另一个值,则一定是大于或等于那个值。然而,在与 NaN 进行比较时这两个比较操作的结果都返回了 false。
  4.相等操作符
确定两个变量是否相等是编程中的一个非常重要的操作。在比较字符串、数值和布尔值的相等性时, 问题还比较简单。但在涉及到对象的比较时,问题就变得复杂了。最早的 ECMAScript 中的相等和不等 操作符会在执行比较之前,先将对象转换成相似的类型。后来,有人提出了这种转换到底是否合理的质 疑。最后,ECMAScript 的解决方案就是提供两组操作符:相等和不相等——先转换再比较,全等和不 全等——仅比较而不转换。
1. 相等和不相等 11
ECMAScript 中的相等操作符由两个等于号(==)表示,如果两个操作数相等,则返回 true。而不 相等操作符由叹号后跟等于号(!=)表示,如果两个操作数不相等,则返回 true。这两个操作符都会 先转换操作数(通常称为强制转型),然后再比较它们的相等性。在转换不同的数据类型时,相等和不相等操作符遵循下列基本规则: 
  如果有一个操作数是布尔值,则在比较相等性之前先将其转换为数值——false 转换为 0,而true 转换为 1;
  如果一个操作数是字符串,另一个操作数是数值,在比较相等性之前先将字符串转换为数值;
  如果一个操作数是对象,另一个操作数不是,则调用对象的 valueOf()方法,用得到的基本类型值按照前面的规则进行比较;
这两个操作符在进行比较时则要遵循下列规则。
  null 和 undefined 是相等的。
  要比较相等性之前,不能将 null 和 undefined 转换成其他任何值。
  如果有一个操作数是 NaN,则相等操作符返回 false,而不相等操作符返回 true。重要提示:
即使两个操作数都是 NaN,相等操作符也返回 false;因为按照规则,NaN 不等于 NaN。
  如果两个操作数都是对象,则比较它们是不是同一个对象。如果两个操作数都指向同一个对象,则相等操作符返回 true;否则,返回 false。 
2. 全等和不全等
除了在比较之前不转换操作数之外,全等和不全等操作符与相等和不相等操作符没有什么区别。全 等操作符由 3 个等于号(===)表示,它只在两个操作数未经转换就相等的情况下返回 true,如下面的 例子所示:
var result1 = ("55" == 55); //true,因为转换后相等
var result2 = ("55" === 55); //false,因为不同的数据类型不相等
在这个例子中,第一个比较使用的是相等操作符比较字符串"55"和数值 55,结果返回了 true。如 前所述,这是因为字符串"55"先被转换成了数值 55,然后再与另一个数值 55 进行比较。第二个比较使 用了全等操作符以不转换数值的方式比较同样的字符串和值。在不转换的情况下,字符串当然不等于数 值,因此结果就是 false。
不全等操作符由一个叹号后跟两个等于号(!==)表示,它在两个操作数未经转换就不相等的情况 下返回 true。例如:
var result1 = ("55" != 55); //false,因为转换后相等
var result2 = ("55" !== 55); //true,因为不同的数据类型不相等 
5. 条件操作符
条件操作符应该算是 ECMAScript 中最灵活的一种操作符了,而且它遵循与 Java 中的条件操作符相同的语法形式,如下面的例子所示:
    var iable = boolean_expression ? true_value : false_value;
本质上,这行代码的含义就是基于对 boolean_expression 求值的结果,决定给变量 variable 赋什么值。如果求值结果为 true,则给变量 variable 赋 true_value 值;如果求值结果为 false, 则给变量 variable 赋 false_value 值。再看一个例子:
    var max = (num1 > num2) ? num1 : num2;
在这个例子中,max 中将会保存一个最大的值。这个表达式的意思是:如果 num1 大于 num2(关 系表达式返回 true),则将 num1 的值赋给 max;如果 num1 小于或等于 num2(关系表达式返回 false), 6 则将 num2 的值赋给 max。 

