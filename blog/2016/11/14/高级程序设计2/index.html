<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>高级程序设计--语法、变量类型、操作符、语句、函数(上) | Hexo</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="语法1.区分大小写要理解的第一个概念就是ECMAcript的一切（变量，函数名和操作符）都区分大小写。这就意味着，变量名test和Test分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字，但typeOf则完全可以是一个有效的函数名。">
<meta property="og:type" content="article">
<meta property="og:title" content="高级程序设计--语法、变量类型、操作符、语句、函数(上)">
<meta property="og:url" content="http://yoursite.com/2016/11/14/高级程序设计2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="语法1.区分大小写要理解的第一个概念就是ECMAcript的一切（变量，函数名和操作符）都区分大小写。这就意味着，变量名test和Test分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字，但typeOf则完全可以是一个有效的函数名。">
<meta property="og:image" content="https://wangjian88.github.io/img/str.gif">
<meta property="og:updated_time" content="2016-11-16T15:09:28.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="高级程序设计--语法、变量类型、操作符、语句、函数(上)">
<meta name="twitter:description" content="语法1.区分大小写要理解的第一个概念就是ECMAcript的一切（变量，函数名和操作符）都区分大小写。这就意味着，变量名test和Test分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字，但typeOf则完全可以是一个有效的函数名。">
<meta name="twitter:image" content="https://wangjian88.github.io/img/str.gif">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://mypics.zhaopin.com//pic/2016/9/29/547D2CA8D4794667B7C86D6568F42953.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">King Jian</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/blog/">主页</a></li>
				        
							<li><a href="/blog/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="linkedin" target="_blank" href="https://wangjian88.github.io" title="linkedin">linkedin</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/blog/tags/hexo/" style="font-size: 10px;">hexo</a> <a href="/blog/tags/js/" style="font-size: 20px;">js</a> <a href="/blog/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/blog/tags/node/" style="font-size: 13.33px;">node</a> <a href="/blog/tags/转载/" style="font-size: 13.33px;">转载</a> <a href="/blog/tags/面试题/" style="font-size: 10px;">面试题</a> <a href="/blog/tags/高级程序设计/" style="font-size: 16.67px;">高级程序设计</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://wangjian88.github.io">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">King Jian</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://mypics.zhaopin.com//pic/2016/9/29/547D2CA8D4794667B7C86D6568F42953.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">King Jian</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/blog/">主页</a></li>
		        
					<li><a href="/blog/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="linkedin" target="_blank" href="https://wangjian88.github.io" title="linkedin">linkedin</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-高级程序设计2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/blog/2016/11/14/高级程序设计2/" class="article-date">
  	<time datetime="2016-11-14T09:55:12.000Z" itemprop="datePublished">2016-11-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      高级程序设计--语法、变量类型、操作符、语句、函数(上)
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/js/">js</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/高级程序设计/">高级程序设计</a></li></ul>
	</div>

        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>1.区分大小写<br>要理解的第一个概念就是ECMAcript的一切（变量，函数名和操作符）都区分大小写。这就意味着，变量名test和Test分别表示两个不同的变量，而函数名不能使用typeof，因为它是一个关键字，但typeOf则完全可以是一个有效的函数名。</p>
<a id="more"></a>
<p>2.标识符</p>
<p>所谓标识符，就是指变量、函数、属性的名，或者函数的参数。标识符命名规则如下：</p>
<blockquote>
<ul>
<li>第一个字符必须是一个字母、下划线(_)或一个美元符号($);</li>
<li>其他字符可以是字母、下划线、美元符号或数字。<br>标识符中的字母也可以包含扩展的 ASCII 或 Unicode 字母字符(如 À 和 Æ),但我们不推荐这样做。 按照惯例,ECMAScript 标识符采用驼峰大小写格式,也就是第一个字母小写,剩下的每个单词的首字母大写,例如:irstSecond myCar  doSomethingImportant</li>
<li>不能把关键字、保留字、true、false 和 null 用作标识符。</li>
</ul>
</blockquote>
<p>3.注释<br>ECMAScript 使用 C 风格的注释,包括单行注释和块级注释。</p>
<blockquote>
<ul>
<li><p>单行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//  alert(1)</div><div class="line">/*	alert(1)</div></pre></td></tr></table></figure>
</li>
<li><p>多行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</div><div class="line">/**	alert(1)</div><div class="line"> 	alert(2)**/</div><div class="line">	alert(3)</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<p>4.关键字和保留字<br>ECMA-262 描述了一组具有特定用途的关键字,这些关键字可用于表示控制语句的开始或结束,或 者用于执行特定操作等。按照规则,关键字也是语言保留的,不能用作标识符。以下就是 ECMAScript 的全部关键字(带*号上标的是第 5 版新增的关键字):<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">break</span> <span class="keyword">case</span> catch <span class="built_in">continue</span> debugger* default delete <span class="keyword">do</span>  instanceof <span class="keyword">else</span>  new  finally  <span class="built_in">return</span> <span class="keyword">for</span> switch <span class="keyword">function</span>     this <span class="keyword">if</span> throwin try typeof var void <span class="keyword">while</span> with</div></pre></td></tr></table></figure></p>
<p>ECMA-262 还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定 的用途,但它们有可能在将来被用作关键字。以下是 ECMA-262 第 3 版定义的全部保留字:</p>
<table>
<thead>
<tr>
<th style="text-align:center">page1</th>
<th style="text-align:center">page2</th>
<th style="text-align:center">page3</th>
<th style="text-align:center">page4</th>
<th style="text-align:center">page5</th>
<th style="text-align:center">page6</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">abstract</td>
<td style="text-align:center">boolean</td>
<td style="text-align:center">byte</td>
<td style="text-align:center">char</td>
<td style="text-align:center">class</td>
<td style="text-align:center">const</td>
</tr>
<tr>
<td style="text-align:center">debugger</td>
<td style="text-align:center">double</td>
<td style="text-align:center">enum</td>
<td style="text-align:center">export</td>
<td style="text-align:center">extends</td>
<td style="text-align:center">final</td>
</tr>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">goto</td>
<td style="text-align:center">import</td>
<td style="text-align:center">int</td>
<td style="text-align:center">interface</td>
<td style="text-align:center">long</td>
</tr>
<tr>
<td style="text-align:center">native</td>
<td style="text-align:center">package</td>
<td style="text-align:center">private</td>
<td style="text-align:center">protected</td>
<td style="text-align:center">public</td>
<td style="text-align:center">implements</td>
</tr>
<tr>
<td style="text-align:center">short</td>
<td style="text-align:center">static</td>
<td style="text-align:center">super</td>
<td style="text-align:center">synchronized</td>
<td style="text-align:center">throws</td>
<td style="text-align:center">transient</td>
</tr>
<tr>
<td style="text-align:center">volatile</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript的变量是松散类型的,所谓松散类型就是可以用来保存任何类型的数据。换句话说,每个变量仅仅是一个用于保存值的占位符而已。定义变量时要使用 var 操作符(注意 var 是一个关键字),后跟变量名(即一个标识符),有一点必须注意,即用 var 操作符定义的变量将成为定义该变量的作用域中的局部变量。也就是说,如果在函数中使用 var 定义一个变量,那么这个变量在函数退出后就会被销毁,例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;</div><div class="line">var message = <span class="string">"hi"</span>; // 局部变量</div><div class="line">&#125;</div><div class="line"><span class="built_in">test</span>();</div><div class="line">alert(message); // 错误!</div></pre></td></tr></table></figure></p>
<p>这里,变量 message 是在函数中使用 var 定义的。当函数被调用时,就会创建该变量并为其赋值。而在此之后,这个变量又会立即被销毁,因此例子中的下一行代码就会导致错误。不过,可以像下面这样省略 var 操作符,从而创建一个全局变量:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">test</span></span>()&#123;					</div><div class="line">	message = <span class="string">"hi"</span>; // 全局变量</div><div class="line">&#125;					</div><div class="line"><span class="built_in">test</span>();</div><div class="line">alert(message); // <span class="string">"hi"</span></div></pre></td></tr></table></figure></p>
<p>这个例子省略了 var 操作符,因而 message 就成了全局变量。这样,只要调用过一次 test()函数,这个变量就有了定义,就可以在函数外部的任何地方被访问到。</p>
<blockquote>
<p>ps:虽然省略 var 操作符可以定义全局变量,但这也不是我们推荐的做法。因为在局部作用域中定义的全局变量很难维护,而且如果有意地忽略了 var 操作符,也会由于相应变量不会马上就有定义而导致不必要的混乱。给未经声明的变量赋值在严格模式下会导致抛出 ReferenceError 错误。</p>
<p>可以使用一条语句定义多个变量,只要像下面这样把每个变量(初始化或不初始化均可)用逗号分隔开即可:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var  message = <span class="string">"hi"</span>,</div><div class="line">     found = <span class="literal">false</span>,</div><div class="line">     age = 29;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>这个例子定义并初始化了 3 个变量。同样由于 ECMAScript 是松散类型的,因而使用不同类型初始化变量的操作可以放在一条语句中来完成。虽然代码里的换行和变量缩进不是必需的,但这样做可以提高可读性。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>ECMAScript 中有 5 种简单数类:Undefined、Null、Boolean、Number,String<br>和 String。还有 1 种复杂数据类型——Object,Object 本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制,而所有值最终都将是上述 6 种数据类型之一。乍一看,好像只有 6种数据类型不足以表示所有数据;但是,由于 ECMAScript 数据类型具有动态性,因此的确没有再定义其他数据类型的必要了。</p>
<p>1.Undefined<br>Undefined类型只有一个值,即特殊的 undefined。在使用 var 声明变量但未对其加以初始化时,这个变量的值就是 undefined,例如:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var message;</div><div class="line">alert(message == undefined); //<span class="literal">true</span></div></pre></td></tr></table></figure></p>
<p>2.Null 类型是第二个只有一个值的数据类型,这个特殊的值是 null。从逻辑角度来看,null 值表示一个空对象指针,而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因,如下面的例子所示:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var car = null;</div><div class="line">alert(typeof car);// <span class="string">"object"</span></div></pre></td></tr></table></figure></p>
<p>如果定义的变量准备在将来用于保存对象,那么最好将该变量初始化为 null 而不是其他值。这样一来,只要直接检查 null 值就可以知道相应的变量是否已经保存了一个对象的引用,如下面的例子所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (car != null)&#123;</div><div class="line">// 对 car 对象执行某些操作					</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上,undefined 值是派生自 null 值的,因此 ECMA-262 规定对它们的相等性测试要返回 true:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(null == undefined);</div></pre></td></tr></table></figure>
<p>如前所述,无论在什么情况下<br>都没有必要把一个变量的值显式地设置为 undefined,可是同样的规则对 null 却不适用。换句话说,只要意在保存对象的变量还没有真正保存对象,就应该明确地让该变量保存 null 值。这样做不仅可以体现 null 作为空对象指针的惯例,而且也有助于进一步区分 null 和 undefined。                </p>
<p>3.Boolean类型<br>Boolean 类型是 ECMAScript 中使用得最多的一种类型,该类型只有两个字面值:true 和 false。这两个值与数字值不是一回事,因此 true 不一定等于 1,而 false 也不一定等于 0。<br>需要注意的是,Boolean 类型的字面值 true 和 false 是区分大小写的。也就是说,True 和 False(以及其他的混合大小写形式)都不是 Boolean 值,只是标识符。            可以对任何数据类型的值调用 Boolean()函数,而且总会返回一个 Boolean 值。至于返回的这个值是 true 还是 false,取决于要转换值的数据类型及其实际值。下表给出了各种数据类型及其对应的转换规则。</p>
<table>
<thead>
<tr>
<th style="text-align:center">数据类型</th>
<th style="text-align:center">转化为true</th>
<th style="text-align:center">转换为false</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">true</td>
<td style="text-align:center">false</td>
</tr>
<tr>
<td style="text-align:center">string</td>
<td style="text-align:center">任何非空字符串</td>
<td style="text-align:center">“”空字符串</td>
</tr>
<tr>
<td style="text-align:center">Number</td>
<td style="text-align:center">任何非零数字值(包括无穷大)</td>
<td style="text-align:center">0和NaN(参见本章后面有关NaN的内容) </td>
</tr>
<tr>
<td style="text-align:center">Object</td>
<td style="text-align:center">任何对象</td>
<td style="text-align:center">null</td>
</tr>
<tr>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">n/a1?</td>
<td style="text-align:center">undifind </td>
</tr>
</tbody>
</table>
<p>4.Number类型<br>Number 类型应该是 ECMAScript 中最令人关注的数据类型了,这种类型使IEEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。为支持各种数值类型,ECMA-262 定义了不同的数值字面量格式。<br>对于那些极大或极小的数值,可以用 e 表示法(即科学计数法)表示的浮点数值表示。用 e 表示法表示的数值等于 e 前面的数值乘以 10 的指数次幂。ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法表示的数值(例如,0.0000003 会被转换成 3e*-7)。<br>var floatNum = 3.125e7; // 等于31250000<br>浮点数值的最高精度是 17 位小数,但在进行算术计算时其精确度远远不如整数。例如,0.1 加 0.2的结果不是 0.3,而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。<br>例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (a + b == 0.3)&#123; // 不要做这样的测试!</div><div class="line">	alert(<span class="string">"You got 0.3."</span>);					</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个例子中,我们测试的是两个数的和是不是等于 0.3。如果这两个数是 0.05 和 0.25,或者是 0.15和 0.15 都不会有问题。而如前所述,如果这两个数是 0.1 和 0.2,那么测试将无法通过。因此,永远不要测试某个特定的浮点数值。</p>
<blockquote>
<p>ps:关于浮点数值计算会产生舍入误差的问题,有一点需要明确:这是使用基于IEEE754 数值的浮点计算的通病,ECMAScript并非独此一家;其他使用相同数值格式的语言也存在这个问题。</p>
<p>NaN<br>NaN,即非数值(Not a Number)是一个特殊的数值,这个数值用于表示一个本来要返回数值的操作数未返回数值的情况(这样就不会抛出错误了)。例如,在其他编程语言中,任何数值除以 0 都会导致错误,从而停止代码执行。但在 ECMAScript 中,任何数值除以 0 会返回 NaN1,因此不会影响其他代码的执行。@原书如此,但实际上只有 0 除以 0 才会返回 NaN,正数除以 0 返回 Infinity,负数除以 0 返回-Infinity。<br>NaN 本身有两个非同寻常的特点。首先,任何涉及 NaN 的操作(例如 NaN/10)都会返回 NaN,这<br>个特点在多步计算中有可能导致问题。其次,NaN 与任何值都不相等,包括 NaN 本身。例如,下面的代码会返回 false:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(NaN == NaN); //<span class="literal">false</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>针对 NaN 的这两个特点,ECMAScript 定义了 isNaN()函数。这个函数接受一个参数,该参数可以<br>是任何类型,而函数会帮我们确定这个参数是否“不是数值”。isNaN()在接收到一个值之后,会尝试<br>将这个值转换为数值。某些不是数值的值会直接转换为数值,例如字符串”10”或 Boolean 值。而任何不能被转换为数值的值都会导致这个函数返回 true。请看下面的例子:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(isNaN(NaN));//<span class="literal">true</span></div><div class="line">alert(isNaN(10));//<span class="literal">false</span>(10 是一个数值)</div><div class="line">alert(isNaN(<span class="string">"10"</span>));//<span class="literal">false</span>(可以被转换成数值 10)</div><div class="line">alert(isNaN(<span class="string">"blue"</span>));//<span class="literal">true</span>(不能转换成数值)</div><div class="line">alert(isNaN(<span class="literal">true</span>));/<span class="literal">false</span>(可以被转换成数值 1)</div></pre></td></tr></table></figure>
<blockquote>
<p>数值转换<br>有 3 个函数可以把非数值转换为数值:Number()、parseInt()和 parseFloat()。第一个函数,<br>即转型函数 Number()可以用于任何数据类型,而另两个函数则专门用于把字符串转换成数值。这 3 个函数对于同样的输入会有返回不同的结果。<br>Number()函数的转换规则如下。<br> 如果是 Boolean 值,true 和 false 将分别被转换为 1 和 0。<br> 如果是数字值,只是简单的传入和返回。<br> 如果是 null 值,返回 0。<br> 如果是 undefined,返回 NaN。<br> 如果是字符串,遵循下列规则:<br>  如果字符串中只包含数字(包括前面带正号或负号的情况),则将其转换为十进制数值,即”1“会变成 1,”123”会变成 123,而”011”会变成 11(注意:前导的零被忽略了);<br>  如果字符串中包含有效的浮点格式,如”1.1”,则将其转换为对应的浮点数值(同样,也会忽略前导零);<br>  如果字符串中包含有效的十六进制格式,例如”0xf”,则将其转换为相同大小的十进制整数值;<br>  如果字符串是空的(不包含任何字符),则将其转换为 0;<br>  如果字符串中包含除上述格式之外的字符,则将其转换为 NaN。<br> 如果是对象,则调用对象的 valueOf()方法,然后依照前面的规则转换返回的值。如果转换的结果是 NaN,则调用对象的 toString()方法,然后再次依照前面的规则转换返回的字符串值。</p>
</blockquote>
<p>由于 Number()函数在转换字符串时比较复杂而且不够合理,因此在处理整数的时候更常用的是parseInt()函数。parseInt()函数在转换字符串时,更多的是看其是否符合数值模式。它会忽略字符串前面的空格,直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号,parseInt()就会返回 NaN;也就是说,用 parseInt()转换空字符串会返回 NaN(Number()对空字符返回 0)。如果第一个字符是数字字符,parseInt()会继续解析第二个字符,直到解析完所有后续字符或者遇到了一个非数字字符。例如,”1234blue”会被转换为 1234,因为”blue”会被完全忽略。类似地,”22.5” 4会被转换为 22,因为小数点并不是有效的数字字符。<br>与 parseInt()函数类似,parseFloat()也是从第一个字符(位置 0)开始解析每个字符。而且也是一直解析到字符串末尾,或者解析到遇见一个无效的浮点数字字符为止。也就是说,字符串中的第一个小数点是有效的,而第二个小数点就是无效的了,因此它后面的字符串将被忽略。举例来说,”22.34.5”将会被转换为 22.34。除了第一个小数点有效之外,parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式,也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成 0。由于 parseFloat()只解析十进制值,因此它没有用第二个参数指定基数的用法。最后还要注意一点:如果字符串包含的是一个可解析为整数的数(没有小数点,或者小数点后都是零),parseFloat()会返回整数。以下是使用 parseFloat()转换数值的几个典型示例。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var num1 = parseFloat(<span class="string">"1234blue"</span>);//1234 (整数)</div><div class="line">var num2 = parseFloat(<span class="string">"0xA"</span>);//0</div><div class="line">var num3 = parseFloat(<span class="string">"22.5"</span>);//22.5</div><div class="line">var num4 = parseFloat(<span class="string">"22.34.5"</span>);//22.34</div><div class="line">var num5 = parseFloat(<span class="string">"0908.5"</span>);//908.5</div><div class="line">var num6 = parseFloat(<span class="string">"3.125e7"</span>);//31250000</div></pre></td></tr></table></figure>
<h4 id="5-String"><a href="#5-String" class="headerlink" title="5.String"></a>5.String</h4><p>String 类型用于表示由零或多个 16 位 Unicode 字符组成的字符序列,即字符串。<br>String 数据类型包含一些特殊的字符字面量,也叫转义序列,用于表示非打印字符,或者具其他用途的字符。这些字符字面量如下表所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">\n     换行</div><div class="line"></div><div class="line">\t     制表</div><div class="line"></div><div class="line">\b     空格</div><div class="line"></div><div class="line">\r     回车</div><div class="line"></div><div class="line">\f     进纸</div><div class="line"></div><div class="line">\\     斜杠</div><div class="line"></div><div class="line">\<span class="string">'     单引号('</span>),在用单引号表示的字符串中使用。例如:<span class="string">'He said, \'</span>hey.\<span class="string">''</span></div><div class="line"></div><div class="line">\<span class="string">"     双引号("</span>),在用双引号表示的字符串中使用。例如:<span class="string">"He said, \"hey.\""</span></div><div class="line"></div><div class="line">\xnn     以十六进制代码nn表示的一个字符(其中n为0~F)。例如,\x41表示<span class="string">"A"</span></div><div class="line"></div><div class="line">\unnnn   以十六进制代码nnnn表示的一个Unicode字符(其中n为0~F)。例如,\u03a3表示希腊字符Σ</div></pre></td></tr></table></figure>
<p>字符串的特点<br>ECMAScript中的字符串是不可变的,也就是说,字符串一旦创建,它们的值就不能改变。要改变某个变量保存的字符串,首先要销毁原来的字符串,然后再用另一个包含新值的字符串填充该量,例如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var lang = <span class="string">"Java"</span>;</div><div class="line">lang = lang + <span class="string">"Script"</span>;</div></pre></td></tr></table></figure>
<p>以上示例中的变量 lang 开始时包含字符串”Java”。而第二行代码把 lang 的值重新定义为”Java”与”Script”的组合,即”JavaScript”。实现这个操作的过程如下:首先创建一个能容纳 10 个字符的新字符串,然后在这个字符串中填充”Java”和”Script”,最后一步是销毁原来的字符串”Java”和字符串”Script”,因为这两个字符串已经没用了。</p>
<div style="text-align:center"><br>    <img src="https://wangjian88.github.io/img/str.gif" alt=""><br></div>

<h4 id="6-Object类型"><a href="#6-Object类型" class="headerlink" title="6.Object类型"></a>6.Object类型</h4><p>ECMAScript 中的对象其实就是一组数据和功能的集合。对象可以通过执行 new 操作符后跟要创建<br>的对象类型的名称来创建。而创建 Object 类型的实例并为其添加属性和(或)方法,就可以创建定义对象,如下所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div></pre></td></tr></table></figure>
<p>这个语法与 Java中创建对象的语法相似;但在ECMAScript中,如果不给构造函数传递参数,则可以省略后面的那一对圆括号。也就是说,在像前面这个示例一样不传递参数的情况下,完全可以省略那对圆括号(但这不是推荐的做法):</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = new Object; // 有效,但不推荐省略圆括号</div></pre></td></tr></table></figure>
<p>仅仅创建 Object 的实例并没有什么用处,但关键是要理解一个重要的思想:即在 ECMAScript 中,(就像 Java 中的 java.lang.Object 对象一样)Object类型是所有它的实例的基础。换句话说, Object 类型所具有的任何属性和方法也同样存在于更具体的对象中。Object 的每个实例都具有下列属性和方法。                    </p>
<blockquote>
<p>1.constructor:保存着用于创建当前对象的函数。对于前面的例子而言,构造函数(constructor) 8就是 Object()。<br>2.hasOwnProperty(propertyName):用于检查给定的属性在当前对象实例中(而不是在实例<br>的原型中)是否存在。其中,作为参数的属性名(propertyName)必须以字符串形式指定(例如:o.hasOwnProperty(“name”))。<br>3.isPrototypeOf(object):用于检查传入的对象是否是传入对象的原型(第 5 章将讨论原型)。<br>4.propertyIsEnumerable(propertyName):用于检查给定的属性是否能够使用 for-in 语句(本章后面将会讨论)来枚举。与 hasOwnProperty()方法一样,作为参数的属性名必须以字符串形式指定。<br>5.toLocaleString():返回对象的字符串表示,该字符串与执行环境的地区对应。<br>6.toString():返回对象的字符串表示。<br>7.valueOf():返回对象的字符串、数值或布尔值表示。通常与 toString()方法的返回值相同。由于在 ECMAScript 中 Object<br>是所有对象的基础,因此所有对象都具有这些基本的属性和方法。第 5 章和第 6 章将详细介绍 Object 与其他对象的关系。</p>
<h4 id="ps-从技术角度讲-ECMA-262-中对象的行为不一定适用于-JavaScript-中的其他对象。浏览器环境中的对象-比如-BOM-和-DOM-中的对象-都属于宿主对象-因为它们是由宿主实现提供和定义的。ECMA-262-不负责定义宿主对象-因此宿主对象可能会也可能不会继承-Object。"><a href="#ps-从技术角度讲-ECMA-262-中对象的行为不一定适用于-JavaScript-中的其他对象。浏览器环境中的对象-比如-BOM-和-DOM-中的对象-都属于宿主对象-因为它们是由宿主实现提供和定义的。ECMA-262-不负责定义宿主对象-因此宿主对象可能会也可能不会继承-Object。" class="headerlink" title="ps:从技术角度讲,ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象,比如 BOM 和 DOM 中的对象,都属于宿主对象,因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象,因此宿主对象可能会也可能不会继承 Object。"></a>ps:从技术角度讲,ECMA-262 中对象的行为不一定适用于 JavaScript 中的其他对象。浏览器环境中的对象,比如 BOM 和 DOM 中的对象,都属于宿主对象,因为它们是由宿主实现提供和定义的。ECMA-262 不负责定义宿主对象,因此宿主对象可能会也可能不会继承 Object。</h4></blockquote>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>ECMA-262 描述了一组用于操作数据值的操作符,包括算术操作符(如加号和减号)、位操作符、 关系操作符和相等操作符。ECMAScript 操作符的与众不同之处在于,它们能够适用于很多值,例如字 符串、数字值、布尔值,甚至对象。不过,在应用于对象时,相应的操作符通常都会调用对象的 valueOf() 和(或)toString()方法,以便取得可以操作的值。<br>1 一元操作符<br>只能操作一个值的操作符叫做一元操作符。一元操作是ECMAScript中最简单的操作符。</p>
<blockquote>
<p>递增和递减操作符<br>递增和递减操作符直接借鉴自 C,而且各有两个版本:前置型和后置型。顾名思义,前置型应该位于要操作的变量之前,而后置型则应该位于要操作的变量之后。因此,在使用前置递增操作符给一个数 值加 1 时,要把两个加号(++)放在这个数值变量前面,如下所示:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var age = 29;</div><div class="line">++age;</div></pre></td></tr></table></figure></p>
<p>在这个例子中,前置递增操作符把 age 的值变成了 30(为 29 加上了 1)。实际上,执行这个前置递 增操作与执行以下操作的效果相同:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var age = 29;</div><div class="line">age = age + 1;</div></pre></td></tr></table></figure></p>
<p>执行前置递减操作的方法也类似,结果会从一个数值中减去 1。使用前置递减操作符时,要把两个 减号(–)放在相应变量的前面,如下所示:<br><figure class="highlight bash"><figcaption><span>var age = 29;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">--age;</div></pre></td></tr></table></figure></p>
<p>这样,age 变量的值就减少为 28(从 29 中减去了 1)。<br>执行前置递增和递减操作时,变量的值都是在语句被求值以前改变的。(在计算机科学领域,这种 情况通常被称作副效应。)请看下面这个例子。<br><figure class="highlight bash"><figcaption><span>var age = 29;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var anotherAge = --age + 2;</div><div class="line">alert(age); // 输出28 </div><div class="line">alert(anotherAge); // 输出30</div></pre></td></tr></table></figure></p>
<p>由于前置递增和递减操作与执行语句的优先级相等,因此整个语句会从左至右被求值。再看一个例子:<br><figure class="highlight bash"><figcaption><span>var num1 = 2;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var num2 = 20;</div><div class="line">var num3 = --num1 + num2;// 等于 21</div><div class="line">var num4 = num1 + num2; // 等于 21</div></pre></td></tr></table></figure></p>
<p>把递增操作符放在变量后面并不会改变语句的结果,因为递增是这条语句的唯一操作。但是,当语 句中还包含其他操作时,上述区别就会非常明显了。请看下面的例子:<br><figure class="highlight bash"><figcaption><span>var num1 = 2;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var num2 = 20; </div><div class="line">var num3 = num1-- + num2; // 等于 22 </div><div class="line">var num4 = num1 + num2;// 21</div></pre></td></tr></table></figure></p>
<p>这里仅仅将前置递减改成了后置递减,就立即可以看到差别。在前面使用前置递减的例子中,num3 和 num4 最后都等于 21。而在这个例子中,num3 等于 22,num4 等于 21。差别的根源在于,这里在计 算 num3 时使用了 num1 的原始值(2)完成了加法计算,而 num4 则使用了递减后的值(1)。</p>
</blockquote>
<h4 id="一元加和减操作符"><a href="#一元加和减操作符" class="headerlink" title="一元加和减操作符"></a>一元加和减操作符</h4><blockquote>
<p>绝大多数开发人员对一元加和减操作符都不会陌生,而且这两个 ECMAScript 操作符的作用与数学 书上讲的完全一样。一元加操作符以一个加号(+)表示,放在数值前面,对数值不会产生任何影响, 如下面的例子所示:<br>var num = 25;<br>num = +num; // 仍然是25<br>不过,在对非数值应用一元加操作符时,该操作符会像 Number()转型函数一样对这个值执行转换。 换句话说,布尔值 false 和 true 将被转换为 0 和 1,字符串值会被按照一组特殊的规则进行解析,而 对象是先调用它们的 valueOf()和(或)toString()方法,再转换得到的值。</p>
</blockquote>
<h4 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h4><blockquote>
<p>在一门编程语言中,布尔操作符的重要性堪比相等操作符。如果没有测试两个值关系的能力,那么 诸如 if…else 和循环之类的语句就不会有用武之地了。布尔操作符一共有 3 个:非(NOT)、与(AND) 和或(OR)。</p>
<ol>
<li>逻辑非<br>逻辑非操作符由一个叹号(!)表示,可以应用于 ECMAScript 中的任何值。无论这个值是什么数据 类型,这个操作符都会返回一个布尔值。逻辑非操作符首先会将它的操作数转换为一个布尔值,然后再 对其求反。也就是说,逻辑非操作符遵循下列规则:<br> 如果操作数是一个对象,返回 false;<br> 如果操作数是一个空字符串,返回 true;<br> 如果操作数是一个非空字符串,返回 false;<br> 如果操作数是数值 0,返回 true;<br> 如果操作数是任意非 0 数值(包括 Infinity),返回 false;<br> 如果操作数是 null,返回 true;<br> 如果操作数是 NaN,返回 true;<br> 如果操作数是 undefined,返回 true。<br>下面几个例子展示了应用上述规则的结果:<br>alert(!false);// true<br>alert(!”blue”);// false<br>alert(!0);// true<br>alert(!NaN);// true<br>alert(!””);// true<br>alert(!12345);// false<br>逻辑非操作符也可以用于将一个值转换为与其对应的布尔值。而同时使用两个逻辑非操作符,实际 上就会模拟 Boolean()转型函数的行为。其中,第一个逻辑非操作会基于无论什么操作数返回一个布 尔值,而第二个逻辑非操作则对该布尔值求反,于是就得到了这个值真正对应的布尔值。当然,最终结 果与对这个值使用 Boolean()函数相同。</li>
<li>逻辑与 逻辑与操作符由两个和号(&amp;&amp;)表示,有两个操作数。 逻辑与操作可以应用于任何类型的操作数,而不仅仅是布尔值。在有一个操作数不是布尔值的情况 下,逻辑与操作就不一定返回布尔值;此时,它遵循下列规则:<br>  如果第一个操作数是对象,则返回第二个操作数;<br>  如果第二个操作数是对象,则只有在第一个操作数的求值结果为 true 的情况下才会返回该对象;<br>  如果两个操作数都是对象,则返回第二个操作数;<br>  如果有一个操作数是 null,则返回 null;<br>  如果有一个操作数是 NaN,则返回 NaN;<br>  如果有一个操作数是 undefined,则返回 undefined。<br>逻辑与操作属于短路操作,即如果第一个操作数能够决定结果,那么就不会再对第二个操作数求值。 对于逻辑与操作而言,如果第一个操作数是 false,则无论第二个操作数是什么值,结果都不再可能是 true 了。来看下面的例子:<br>var found = true;<br>var result = (found &amp;&amp; someUndefinedVariable);/ 这一行不会执行<br>alert(result); // 这里会发生错误<br>在上面的代码中,当执行逻辑与操作时会发生错误,因为变量 someUndefinedVariable 没有声 明。由于变量 found 的值是 true,所以逻辑与操作符会继续对变量 someUndefinedVariable 求值。但 someUndefinedVariable 尚未定义,因此就会导致错误。这说明不能在逻辑与操作中使用未定义 的值。如果像下面这个例中一样,将 found 的值设置为 false,就不会发生错误了:<br>var found = false;<br>var result = (found &amp;&amp; someUndefinedVariable); alert(result); // 会执行(“false”)<br>在这个例子中,警告框会显示出来。无论变量 someUndefinedVariable 有没有定义,也永远不 会对它求值,因为第一个操作数的值是 false。而这也就意味着逻辑与操作的结果必定是 false,根本 用不着再对&amp;&amp;右侧的操作数求值了。在使用逻辑与操作符时要始终铭记它是一个短路操作符。</li>
<li>逻辑或 逻辑或操作符由两个竖线符号(||)表示,有两个操作数<br>与逻辑与操作相似,如果有一个操作数不是布尔值,逻辑或也不一定返回布尔值;此时,它遵循下 列规则:<br> 如果第一个操作数是对象,则返回第一个操作数;<br> 如果第一个操作数的求值结果为 false,则返回第二个操作数;<br> 如果两个操作数都是对象,则返回第一个操作数;<br> 如果两个操作数都是 null,则返回 null;<br> 如果两个操作数都是 NaN,则返回 NaN;<br> 如果两个操作数都是 undefined,则返回 undefined。<br>与逻辑与操作符相似,逻辑或操作符也是短路操作符。也就是说,如果第一个操作数的求值结果为 true,就不会对第二个操作数求值了。下面看一个例子:<br>var found = true;<br>var result = (found || someUndefinedVariable); // 不会发生错误 alert(result); // 会执行(“true”)<br>我们可以利用逻辑或的这一行为来避免为变量赋 null 或 undefined 值。例如:<br>var myObject = preferredObject || backupObject;<br>在这个例子中,变量 myObject 将被赋予等号后面两个值中的一个。变量 preferredObject 中包 含优先赋给变量 myObject 的值,变量 backupObject 负责在 preferredObject 中不包含有效值的情况下提供后备值。如果preferredObject 的值不是 null,那么它的值将被赋给 myObject;如果 1 是 null,则将 backupObject 的值赋给 myObject。ECMAScript 程序的赋值语句经常会使用这种模式, 本书也将采用这种模式。<br>3 关系操作符<br>小于(&lt;)、大于(&gt;)、小于等于(&lt;=)和大于等于(&gt;=)这几个关系操作符用于对两个值进行比较,比较的规则与我们在数学课上所学的一样。这几个操作符都返回一个布尔值,如下面的例子所示:<br>var result1 = 5 &gt; 3; //true<br>var result2 = 5 &lt; 3; //false<br>与 ECMAScript 中的其他操作符一样,当关系操作符的操作数使用了非数值时,也要进行数据转换 或完成某些奇怪的操作。以下就是相应的规则。<br>  如果两个操作数都是数值,则执行数值比较。<br>  如果两个操作数都是字符串,则比较两个字符串对应的字符编码值。<br>  如果一个操作数是数值,则将另一个操作数转换为一个数值,然后执行数值比较。<br>  如果一个操作数是对象,则调用这个对象的 valueOf()方法,用得到的结果按照前面的规则执行比较。如果对象没有 valueOf()方法,则调用 toString()方法,并用得到的结果根据前面的规则执行比较。<br>  如果一个操作数是布尔值,则先将其转换为数值,然后再执行比较<br>在使用关系操作符比较两个字符串时,会执行一种奇怪的操作。很多人都会认为,在比较字符串值 时,小于的意思是“在字母表中的位置靠前”,而大于则意味着“在字母表中的位置靠后”,但实际上完 全不是那么回事。在比较字符串时,实际比较的是两个字符串中对应位置的每个字符的字符编码值。经 过这么一番比较之后,再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码,因 此我们就会看到如下所示的奇怪现象:<br>var result = “Brick” &lt; “alphabet”;    //true<br>在这个例子中,字符串”Brick”被认为小于字符串”alphabet”。原因是字母 B 的字符编码为 66, 而字母 a 的字符编码是 97。如果要真正按字母表顺序比较字符串,就必须把两个操作数转换为相同的大 小写形式(全部大写或全部小写),然后再执行比较,如下所示:<br>var result = “Brick”.toLowerCase() &lt; “alphabet”.toLowerCase();<br>//false<br>通过将两个操作数都转换为小写形式,就可以得出”alphabet”按字母表顺序排在”Brick”之前的 正确判断了。另一种奇怪的现象发生在比较两个数字字符串的情况下,比如下面这个例子:<br>var result = “23” &lt; “3”;    //true<br>确实,当比较字符串”23”是否小于”3”时,结果居然是 true。这是因为两个操作数都是字符串, 而字符串比较的是字符编码(“2”的字符编码是 50,而”3”的字符编码是 51)。不过,如果像下面例子 中一样,将一个操作数改为数值,比较的结果就正常了:<br>var result = “23” &lt; 3;    //false<br>此时,字符串”23”会被转换成数值 23,然后再与 3 进行比较,因此就会得到合理的结果。在比较 数值和字符串时,字符串都会被转换成数值,然后再以数值方式与另一个数值比较。当然,这个规则对 前面的例子是适用的。可是,如果那个字符串不能被转换成一个合理的数值呢?比如:<br>var result = “a” &lt; 3; // false,因为”a”被转换成了 NaN<br>由于字母”a”不能转换成合理的数值,因此就被转换成了 NaN。根据规则,任何操作数与 NaN 进行关系比较，结果都是false。于是，就有了下面有趣的现象<br>var result1 = NaN &lt; 3; //false<br>var result2 = NaN &gt;= 3; //false<br>按照常理,如果一个值不小于另一个值,则一定是大于或等于那个值。然而,在与 NaN 进行比较时这两个比较操作的结果都返回了 false。<br>4.相等操作符<br>确定两个变量是否相等是编程中的一个非常重要的操作。在比较字符串、数值和布尔值的相等性时, 问题还比较简单。但在涉及到对象的比较时,问题就变得复杂了。最早的 ECMAScript 中的相等和不等 操作符会在执行比较之前,先将对象转换成相似的类型。后来,有人提出了这种转换到底是否合理的质 疑。最后,ECMAScript 的解决方案就是提供两组操作符:相等和不相等——先转换再比较,全等和不 全等——仅比较而不转换。</li>
<li>相等和不相等 11<br>ECMAScript 中的相等操作符由两个等于号(==)表示,如果两个操作数相等,则返回 true。而不 相等操作符由叹号后跟等于号(!=)表示,如果两个操作数不相等,则返回 true。这两个操作符都会 先转换操作数(通常称为强制转型),然后再比较它们的相等性。在转换不同的数据类型时,相等和不相等操作符遵循下列基本规则:<br>  如果有一个操作数是布尔值,则在比较相等性之前先将其转换为数值——false 转换为 0,而true 转换为 1;<br>  如果一个操作数是字符串,另一个操作数是数值,在比较相等性之前先将字符串转换为数值;<br>  如果一个操作数是对象,另一个操作数不是,则调用对象的 valueOf()方法,用得到的基本类型值按照前面的规则进行比较;<br>这两个操作符在进行比较时则要遵循下列规则。<br>  null 和 undefined 是相等的。<br>  要比较相等性之前,不能将 null 和 undefined 转换成其他任何值。<br>  如果有一个操作数是 NaN,则相等操作符返回 false,而不相等操作符返回 true。重要提示:<br>即使两个操作数都是 NaN,相等操作符也返回 false;因为按照规则,NaN 不等于 NaN。<br>  如果两个操作数都是对象,则比较它们是不是同一个对象。如果两个操作数都指向同一个对象,则相等操作符返回 true;否则,返回 false。 </li>
<li>全等和不全等<br>除了在比较之前不转换操作数之外,全等和不全等操作符与相等和不相等操作符没有什么区别。全 等操作符由 3 个等于号(===)表示,它只在两个操作数未经转换就相等的情况下返回 true,如下面的 例子所示:<br>var result1 = (“55” == 55); //true,因为转换后相等<br>var result2 = (“55” === 55); //false,因为不同的数据类型不相等<br>在这个例子中,第一个比较使用的是相等操作符比较字符串”55”和数值 55,结果返回了 true。如 前所述,这是因为字符串”55”先被转换成了数值 55,然后再与另一个数值 55 进行比较。第二个比较使 用了全等操作符以不转换数值的方式比较同样的字符串和值。在不转换的情况下,字符串当然不等于数 值,因此结果就是 false。<br>不全等操作符由一个叹号后跟两个等于号(!==)表示,它在两个操作数未经转换就不相等的情况 下返回 true。例如:<br>var result1 = (“55” != 55); //false,因为转换后相等<br>var result2 = (“55” !== 55); //true,因为不同的数据类型不相等 </li>
<li>条件操作符<br>条件操作符应该算是 ECMAScript 中最灵活的一种操作符了,而且它遵循与 Java 中的条件操作符相同的语法形式,如下面的例子所示:<br> var iable = boolean_expression ? true_value : false_value;<br>本质上,这行代码的含义就是基于对 boolean_expression 求值的结果,决定给变量 variable 赋什么值。如果求值结果为 true,则给变量 variable 赋 true_value 值;如果求值结果为 false, 则给变量 variable 赋 false_value 值。再看一个例子:<br> var max = (num1 &gt; num2) ? num1 : num2;<br>在这个例子中,max 中将会保存一个最大的值。这个表达式的意思是:如果 num1 大于 num2(关 系表达式返回 true),则将 num1 的值赋给 max;如果 num1 小于或等于 num2(关系表达式返回 false), 6 则将 num2 的值赋给 max。 </li>
</ol>
</blockquote>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2016/11/14/高级程序设计3/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">&lt;</strong>
      <div class="article-nav-title">
        
          高级程序设计--语法、变量类型、操作符、语句、函数(下)
        
      </div>
    </a>
  
  
    <a href="/blog/2016/07/12/面试题/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">精选面试题</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="高级程序设计2" data-title="高级程序设计--语法、变量类型、操作符、语句、函数(上)" data-url="http://yoursite.com/blog/2016/11/14/高级程序设计2/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"wj200819"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>







<script type="text/javascript">

  (function(t){function e(t){return t.replace(/(:|\.)/g,"\\$1")}var l="1.4.13",o={},s={exclude:[],excludeWithin:[],offset:0,direction:"top",scrollElement:null,scrollTarget:null,beforeScroll:function(){},afterScroll:function(){},easing:"swing",speed:400,autoCoefficent:2,preventDefault:!0},n=function(e){var l=[],o=!1,s=e.dir&&"left"==e.dir?"scrollLeft":"scrollTop";return this.each(function(){if(this!=document&&this!=window){var e=t(this);e[s]()>0?l.push(this):(e[s](1),o=e[s]()>0,o&&l.push(this),e[s](0))}}),l.length||this.each(function(){"BODY"===this.nodeName&&(l=[this])}),"first"===e.el&&l.length>1&&(l=[l[0]]),l};t.fn.extend({scrollable:function(t){var e=n.call(this,{dir:t});return this.pushStack(e)},firstScrollable:function(t){var e=n.call(this,{el:"first",dir:t});return this.pushStack(e)},smoothScroll:function(l,o){if(l=l||{},"options"===l)return o?this.each(function(){var e=t(this),l=t.extend(e.data("ssOpts")||{},o);t(this).data("ssOpts",l)}):this.first().data("ssOpts");var s=t.extend({},t.fn.smoothScroll.defaults,l),n=t.smoothScroll.filterPath(location.pathname);return this.unbind("click.smoothscroll").bind("click.smoothscroll",function(l){var o=this,r=t(this),i=t.extend({},s,r.data("ssOpts")||{}),c=s.exclude,a=i.excludeWithin,f=0,h=0,u=!0,d={},p=location.hostname===o.hostname||!o.hostname,m=i.scrollTarget||(t.smoothScroll.filterPath(o.pathname)||n)===n,S=e(o.hash);if(i.scrollTarget||p&&m&&S){for(;u&&c.length>f;)r.is(e(c[f++]))&&(u=!1);for(;u&&a.length>h;)r.closest(a[h++]).length&&(u=!1)}else u=!1;u&&(i.preventDefault&&l.preventDefault(),t.extend(d,i,{scrollTarget:i.scrollTarget||S,link:o}),t.smoothScroll(d))}),this}}),t.smoothScroll=function(e,l){if("options"===e&&"object"==typeof l)return t.extend(o,l);var s,n,r,i,c=0,a="offset",f="scrollTop",h={},u={};"number"==typeof e?(s=t.extend({link:null},t.fn.smoothScroll.defaults,o),r=e):(s=t.extend({link:null},t.fn.smoothScroll.defaults,e||{},o),s.scrollElement&&(a="position","static"==s.scrollElement.css("position")&&s.scrollElement.css("position","relative"))),f="left"==s.direction?"scrollLeft":f,s.scrollElement?(n=s.scrollElement,/^(?:HTML|BODY)$/.test(n[0].nodeName)||(c=n[f]())):n=t("html, body").firstScrollable(s.direction),s.beforeScroll.call(n,s),r="number"==typeof e?e:l||t(s.scrollTarget)[a]()&&t(s.scrollTarget)[a]()[s.direction]||0,h[f]=r+c+s.offset,i=s.speed,"auto"===i&&(i=h[f]||n.scrollTop(),i/=s.autoCoefficent),u={duration:i,easing:s.easing,complete:function(){s.afterScroll.call(s.link,s)}},s.step&&(u.step=s.step),n.length?n.stop().animate(h,u):s.afterScroll.call(s.link,s)},t.smoothScroll.version=l,t.smoothScroll.filterPath=function(t){return t.replace(/^\//,"").replace(/(?:index|default).[a-zA-Z]{3,4}$/,"").replace(/\/$/,"")},t.fn.smoothScroll.defaults=s})(jQuery);

  (function(){var t=[].indexOf||function(t){for(var e=0,n=this.length;e<n;e++){if(e in this&&this[e]===t)return e}return-1},e=[].slice;(function(t,e){if(typeof define==="function"&&define.amd){return define("waypoints",["jquery"],function(n){return e(n,t)})}else{return e(t.jQuery,t)}})(window,function(n,r){var i,o,l,s,f,u,c,a,h,d,p,y,v,w,g,m;i=n(r);a=t.call(r,"ontouchstart")>=0;s={horizontal:{},vertical:{}};f=1;c={};u="waypoints-context-id";p="resize.waypoints";y="scroll.waypoints";v=1;w="waypoints-waypoint-ids";g="waypoint";m="waypoints";o=function(){function t(t){var e=this;this.$element=t;this.element=t[0];this.didResize=false;this.didScroll=false;this.id="context"+f++;this.oldScroll={x:t.scrollLeft(),y:t.scrollTop()};this.waypoints={horizontal:{},vertical:{}};this.element[u]=this.id;c[this.id]=this;t.bind(y,function(){var t;if(!(e.didScroll||a)){e.didScroll=true;t=function(){e.doScroll();return e.didScroll=false};return r.setTimeout(t,n[m].settings.scrollThrottle)}});t.bind(p,function(){var t;if(!e.didResize){e.didResize=true;t=function(){n[m]("refresh");return e.didResize=false};return r.setTimeout(t,n[m].settings.resizeThrottle)}})}t.prototype.doScroll=function(){var t,e=this;t={horizontal:{newScroll:this.$element.scrollLeft(),oldScroll:this.oldScroll.x,forward:"right",backward:"left"},vertical:{newScroll:this.$element.scrollTop(),oldScroll:this.oldScroll.y,forward:"down",backward:"up"}};if(a&&(!t.vertical.oldScroll||!t.vertical.newScroll)){n[m]("refresh")}n.each(t,function(t,r){var i,o,l;l=[];o=r.newScroll>r.oldScroll;i=o?r.forward:r.backward;n.each(e.waypoints[t],function(t,e){var n,i;if(r.oldScroll<(n=e.offset)&&n<=r.newScroll){return l.push(e)}else if(r.newScroll<(i=e.offset)&&i<=r.oldScroll){return l.push(e)}});l.sort(function(t,e){return t.offset-e.offset});if(!o){l.reverse()}return n.each(l,function(t,e){if(e.options.continuous||t===l.length-1){return e.trigger([i])}})});return this.oldScroll={x:t.horizontal.newScroll,y:t.vertical.newScroll}};t.prototype.refresh=function(){var t,e,r,i=this;r=n.isWindow(this.element);e=this.$element.offset();this.doScroll();t={horizontal:{contextOffset:r?0:e.left,contextScroll:r?0:this.oldScroll.x,contextDimension:this.$element.width(),oldScroll:this.oldScroll.x,forward:"right",backward:"left",offsetProp:"left"},vertical:{contextOffset:r?0:e.top,contextScroll:r?0:this.oldScroll.y,contextDimension:r?n[m]("viewportHeight"):this.$element.height(),oldScroll:this.oldScroll.y,forward:"down",backward:"up",offsetProp:"top"}};return n.each(t,function(t,e){return n.each(i.waypoints[t],function(t,r){var i,o,l,s,f;i=r.options.offset;l=r.offset;o=n.isWindow(r.element)?0:r.$element.offset()[e.offsetProp];if(n.isFunction(i)){i=i.apply(r.element)}else if(typeof i==="string"){i=parseFloat(i);if(r.options.offset.indexOf("%")>-1){i=Math.ceil(e.contextDimension*i/100)}}r.offset=o-e.contextOffset+e.contextScroll-i;if(r.options.onlyOnScroll&&l!=null||!r.enabled){return}if(l!==null&&l<(s=e.oldScroll)&&s<=r.offset){return r.trigger([e.backward])}else if(l!==null&&l>(f=e.oldScroll)&&f>=r.offset){return r.trigger([e.forward])}else if(l===null&&e.oldScroll>=r.offset){return r.trigger([e.forward])}})})};t.prototype.checkEmpty=function(){if(n.isEmptyObject(this.waypoints.horizontal)&&n.isEmptyObject(this.waypoints.vertical)){this.$element.unbind([p,y].join(" "));return delete c[this.id]}};return t}();l=function(){function t(t,e,r){var i,o;if(r.offset==="bottom-in-view"){r.offset=function(){var t;t=n[m]("viewportHeight");if(!n.isWindow(e.element)){t=e.$element.height()}return t-n(this).outerHeight()}}this.$element=t;this.element=t[0];this.axis=r.horizontal?"horizontal":"vertical";this.callback=r.handler;this.context=e;this.enabled=r.enabled;this.id="waypoints"+v++;this.offset=null;this.options=r;e.waypoints[this.axis][this.id]=this;s[this.axis][this.id]=this;i=(o=this.element[w])!=null?o:[];i.push(this.id);this.element[w]=i}t.prototype.trigger=function(t){if(!this.enabled){return}if(this.callback!=null){this.callback.apply(this.element,t)}if(this.options.triggerOnce){return this.destroy()}};t.prototype.disable=function(){return this.enabled=false};t.prototype.enable=function(){this.context.refresh();return this.enabled=true};t.prototype.destroy=function(){delete s[this.axis][this.id];delete this.context.waypoints[this.axis][this.id];return this.context.checkEmpty()};t.getWaypointsByElement=function(t){var e,r;r=t[w];if(!r){return[]}e=n.extend({},s.horizontal,s.vertical);return n.map(r,function(t){return e[t]})};return t}();d={init:function(t,e){var r;e=n.extend({},n.fn[g].defaults,e);if((r=e.handler)==null){e.handler=t}this.each(function(){var t,r,i,s;t=n(this);i=(s=e.context)!=null?s:n.fn[g].defaults.context;if(!n.isWindow(i)){i=t.closest(i)}i=n(i);r=c[i[0][u]];if(!r){r=new o(i)}return new l(t,r,e)});n[m]("refresh");return this},disable:function(){return d._invoke.call(this,"disable")},enable:function(){return d._invoke.call(this,"enable")},destroy:function(){return d._invoke.call(this,"destroy")},prev:function(t,e){return d._traverse.call(this,t,e,function(t,e,n){if(e>0){return t.push(n[e-1])}})},next:function(t,e){return d._traverse.call(this,t,e,function(t,e,n){if(e<n.length-1){return t.push(n[e+1])}})},_traverse:function(t,e,i){var o,l;if(t==null){t="vertical"}if(e==null){e=r}l=h.aggregate(e);o=[];this.each(function(){var e;e=n.inArray(this,l[t]);return i(o,e,l[t])});return this.pushStack(o)},_invoke:function(t){this.each(function(){var e;e=l.getWaypointsByElement(this);return n.each(e,function(e,n){n[t]();return true})});return this}};n.fn[g]=function(){var t,r;r=arguments[0],t=2<=arguments.length?e.call(arguments,1):[];if(d[r]){return d[r].apply(this,t)}else if(n.isFunction(r)){return d.init.apply(this,arguments)}else if(n.isPlainObject(r)){return d.init.apply(this,[null,r])}else if(!r){return n.error("jQuery Waypoints needs a callback function or handler option.")}else{return n.error("The "+r+" method does not exist in jQuery Waypoints.")}};n.fn[g].defaults={context:r,continuous:true,enabled:true,horizontal:false,offset:0,triggerOnce:false};h={refresh:function(){return n.each(c,function(t,e){return e.refresh()})},viewportHeight:function(){var t;return(t=r.innerHeight)!=null?t:i.height()},aggregate:function(t){var e,r,i;e=s;if(t){e=(i=c[n(t)[0][u]])!=null?i.waypoints:void 0}if(!e){return[]}r={horizontal:[],vertical:[]};n.each(r,function(t,i){n.each(e[t],function(t,e){return i.push(e)});i.sort(function(t,e){return t.offset-e.offset});r[t]=n.map(i,function(t){return t.element});return r[t]=n.unique(r[t])});return r},above:function(t){if(t==null){t=r}return h._filter(t,"vertical",function(t,e){return e.offset<=t.oldScroll.y})},below:function(t){if(t==null){t=r}return h._filter(t,"vertical",function(t,e){return e.offset>t.oldScroll.y})},left:function(t){if(t==null){t=r}return h._filter(t,"horizontal",function(t,e){return e.offset<=t.oldScroll.x})},right:function(t){if(t==null){t=r}return h._filter(t,"horizontal",function(t,e){return e.offset>t.oldScroll.x})},enable:function(){return h._invoke("enable")},disable:function(){return h._invoke("disable")},destroy:function(){return h._invoke("destroy")},extendFn:function(t,e){return d[t]=e},_invoke:function(t){var e;e=n.extend({},s.vertical,s.horizontal);return n.each(e,function(e,n){n[t]();return true})},_filter:function(t,e,r){var i,o;i=c[n(t)[0][u]];if(!i){return[]}o=[];n.each(i.waypoints[e],function(t,e){if(r(i,e)){return o.push(e)}});o.sort(function(t,e){return t.offset-e.offset});return n.map(o,function(t){return t.element})}};n[m]=function(){var t,n;n=arguments[0],t=2<=arguments.length?e.call(arguments,1):[];if(h[n]){return h[n].apply(null,t)}else{return h.aggregate.call(null,n)}};n[m].settings={resizeThrottle:100,scrollThrottle:30};return i.on("load.waypoints",function(){return n[m]("refresh")})})}).call(this);
  
    

 $(function(){
      if(window.location.href.length >= 34){
        var str = '<p style="font-size:20px;color:red;margin-bottom:10px">文章大纲</p><ul id= "dagang" class="nav" style="line-height:30px;color:white">'
        $('.social').css('display','none');
        for(var i=0;i < $('h3').length;i++){
            str += '<li><a style="color:white;"  href=#' + $('h3').eq(i).text() + '>'+ $('h3').eq(i).text() +'</a></li>'
        }
        str += '</ul>'
        $('.switch-part').append(str)
        $('#dagang a').smoothScroll({speed: 1200}); 
      }
  })
</script></div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2016 King Jian
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/winnerweb/hexo-Yilia-Smackdown" target="_blank">Yilia(Smackdown)</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/blog/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>